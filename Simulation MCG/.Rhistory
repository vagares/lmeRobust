summaryMLE = Roblme(dat$Y,dat$X,dat$Z,E=NULL,L=dat$L,
rho="MLE",rhoMM=NULL,eps=1e-5,maxiter=100,eff=0.95,V0=NULL)
# Roblme for S
summaryS = Roblme(dat$Y,dat$X,dat$Z,E=NULL,L=dat$L,
rho="biweight",rhoMM=NULL,eps=1e-5,maxiter=100,eff=0.95,V0=NULL)
# Roblme for MM
summaryMM = Roblme(dat$Y,dat$X,dat$Z,E=NULL,L=dat$L,
rho="biweight",rhoMM="biweight",eps=1e-5,maxiter=100,eff=0.95,V0=NULL)
# varComprob
y=vec(t(dat$Y))
Dataset=data.frame(y,time,groups)
summarycTAU=varComprob(y ~ 1 +  time, groups = groups, data = Dataset, varcov = K, control = varComprob.control(lower = c(0, 0, -Inf)))
betahatmatMLE[m,]=summaryMLE$fixedeffectsS[,1]
betahatmatS[m,]=summaryS$fixedeffectsS[,1]
betahatmatMM[m,]=summaryMM$fixedeffectsMM[,1]
betahatmatcTAU[m,]=summarycTAU$beta
thetahatmatMLE[m,]=summaryMLE$summarythetaS[,1]
thetahatmatS[m,]=summaryS$summarythetaS[,1]
thetahatmatMM[m,]=summaryMM$summarythetaS[,1]
thetahatmatcTAU[m,]=c(summarycTAU$eta,summarycTAU$eta0)
asympvarbetaMLE[[m]]=summaryMLE$varbetaShat
asympvarbetaS[[m]]=summaryS$varbetaShat
asympvarbetaMM[[m]]=summaryMM$varbetaMMhat
asympvarbetacTAU[[m]]=summarycTAU$vcov.beta
asympvarthetaMLE[[m]]=summaryMLE$varthetahat
asympvarthetaS[[m]]=summaryS$varthetahat
asympvarthetaMM[[m]]=summaryMM$varthetahat
no_outliers[m,]=c(dat$nobi,dat$noei,dat$noxi,dat$noe,dat$nox)
print(m)
}
MLE=list()
MLE[[1]]=betahatmatMLE
MLE[[2]]=asympvarbetaMLE
MLE[[3]]=thetahatmatMLE
MLE[[4]]=asympvarthetaMLE
names(MLE)=c("beta","varbeta","theta","vartheta")
Sest=list()
Sest[[1]]=betahatmatS
Sest[[2]]=asympvarbetaS
Sest[[3]]=thetahatmatS
Sest[[4]]=asympvarthetaS
names(Sest)=c("beta","varbeta","theta","vartheta")
MM=list()
MM[[1]]=betahatmatMM
MM[[2]]=asympvarbetaMM
MM[[3]]=thetahatmatMM
MM[[4]]=asympvarthetaMM
names(MM)=c("beta","varbeta","theta","vartheta")
cTAU=list()
cTAU[[1]]=betahatmatcTAU
cTAU[[2]]=asympvarbetacTAU
cTAU[[3]]=thetahatmatcTAU
cTAU[[4]]=matrix(0,nrow=k,ncol=k)
names(cTAU)=c("beta","varbeta","theta","vartheta")
no_outliers=data.frame(no_outliers)
names(no_outliers)=c("nobi","noei","noxi","noe","nox")
MLESMMcTAU=list()
MLESMMcTAU[[1]]=MLE
MLESMMcTAU[[2]]=Sest
MLESMMcTAU[[3]]=MM
MLESMMcTAU[[4]]=cTAU
MLESMMcTAU[[5]]=no_outliers
names(MLESMMcTAU)=c("MLE","S","MM","cTAU","no_outliers")
return(MLESMMcTAU)
}
#
# The user first specifies the contamination scenarios.
# The script runs the simulation for these scenarios using
# the function MLESMMcTAU_estimates_MCG and data_gen_MCR
#
# After the simulation for a scenario has been completed
# this script saves the results in .RData files
# containing a list MLESMMcTAU
# The .Rdata files are stored in designated subfolders
# BEFORE running this script, first create subfolders
# - Results_Uncontaminated
# - Results_Epsilon_contamination
# - Results_Random_Effect_contamination
# - Results_X_contamination
source("biweight_functions.R")
source("asympt_norm_constants.R")
source("function_data_gen_MCG.R")
source("Robust_lme.R")
source("function_MLESMMcTAU_estimates_MCG.R")
library(robustbase)
library(lava)
# Information for ourselves
# beta=c(250,10)
# beta1=gamma0
# beta2=gamma1
# theta=c(790,-8.5,40,400)
# theta1=sigma0^2
# theta2=sigma10
# theta3=sigma1^2
# theta4=sigmaeps^2
pe=0.05
pb=0.05
px=0.05
nrep=1
# creating a dataframe that contains different contamination schemes as rows:
# n number of individuals
# k number of observations per individual
# pe probability of having outlier in component epsilon_ij
# pb probability of having outlier in vector of random effects b
# px probability of having outlier in component x_ij in X
# mec shift in the mean of component epsilon_ij
# mbc2 shift in the mean of random effect b2
# alphac multiplication factor in component x_ij in X
scenarios=NULL
scenarios=rbind(scenarios,c(nrep,200,4,pe,0,0,-80,0,1))
scenarios=rbind(scenarios,c(nrep,200,4,0,pb,0,0,-25,1))
scenarios=rbind(scenarios,c(nrep,200,4,0,0,px,0,0,10))
colnames(scenarios)=c("nrep","n","k","pe","pb","px","mec","mbc2","alphac")
scenarios=data.frame(scenarios)
set.seed(11131957)
for (i in (1:nrow(scenarios))){
nrep=scenarios[i,1]
nsample=scenarios[i,2]
ksample=scenarios[i,3]
pesample=scenarios[i,4]
pbsample=scenarios[i,5]
pxsample=scenarios[i,6]
mecsample=scenarios[i,7]
mbc2sample=scenarios[i,8]
alphacsample=scenarios[i,9]
MLESMMcTAU=MLESMMcTAU_estimates_MCG(nrep=nrep,n=nsample,k=ksample,
pe=pesample,pb=pbsample,px=pxsample,
mec=mecsample,mbc2=mbc2sample,
alphac=alphacsample)
if (pe>0){
flname=paste0("./Results_Epsilon_contamination/","MLESMMcTAU","_",
"nrep=",nrep,"_",
"n=",nsample,"_",
"k=",ksample,"_",
"pe=",pesample,"_",
"pb=",pbsample,"_",
"px=",pxsample,"_",
"mec=",mecsample,"_",
"mbc2=",mbc2sample,"_",
"alphac=",alphacsample,"_",
".RData")}else{
flname=paste0("./Results_Uncontaminated/","MLESMMcTAU","_",
"nrep=",nrep,"_",
"n=",nsample,"_",
"k=",ksample,"_",
"pe=",pesample,"_",
"pb=",pbsample,"_",
"px=",pxsample,"_",
"mec=",mecsample,"_",
"mbc2=",mbc2sample,"_",
"alphac=",alphacsample,"_",
".RData")}
if (pb>0){
flname=paste0("./Results_Random_Effect_contamination/","MLESMMcTAU","_",
"nrep=",nrep,"_",
"n=",nsample,"_",
"k=",ksample,"_",
"pe=",pesample,"_",
"pb=",pbsample,"_",
"px=",pxsample,"_",
"mec=",mecsample,"_",
"mbc2=",mbc2sample,"_",
"alphac=",alphacsample,"_",
".RData")}
if (px>0){
flname=paste0("./Results_X_contamination/","MLESMMcTAU","_",
"nrep=",nrep,"_",
"n=",nsample,"_",
"k=",ksample,"_",
"pe=",pesample,"_",
"pb=",pbsample,"_",
"px=",pxsample,"_",
"mec=",mecsample,"_",
"mbc2=",mbc2sample,"_",
"alphac=",alphacsample,"_",
".RData")}
save(MLESMMcTAU,file=flname)
}
setwd("C:/Users/rlopuhaa/surfdrive/LOPUHAA/Research/Toulouse/Visit 2023 Februari/Rstuff Februari 2023/Simulation MCG")
setwd("C:/Users/rlopuhaa/surfdrive/LOPUHAA/Research/Toulouse/Visit 2023 Februari/Rstuff Februari 2023/Simulation MCG")
source("biweight_functions.R")
source("asympt_norm_constants.R")
source("function_data_gen_MCG.R")
source("Robust_lme.R")
source("function_MLESMMcTAU_estimates_MCG.R")
library(robustbase)
library(lava)
# Information for ourselves
# beta=c(250,10)
# beta1=gamma0
# beta2=gamma1
# theta=c(790,-8.5,40,400)
# theta1=sigma0^2
# theta2=sigma10
# theta3=sigma1^2
# theta4=sigmaeps^2
pe=0.05
pb=0.05
px=0.05
nrep=1
# creating a dataframe that contains different contamination schemes as rows:
# n number of individuals
# k number of observations per individual
# pe probability of having outlier in component epsilon_ij
# pb probability of having outlier in vector of random effects b
# px probability of having outlier in component x_ij in X
# mec shift in the mean of component epsilon_ij
# mbc2 shift in the mean of random effect b2
# alphac multiplication factor in component x_ij in X
scenarios=NULL
scenarios=rbind(scenarios,c(nrep,200,4,pe,0,0,-80,0,1))
scenarios=rbind(scenarios,c(nrep,200,4,0,pb,0,0,-25,1))
scenarios=rbind(scenarios,c(nrep,200,4,0,0,px,0,0,10))
colnames(scenarios)=c("nrep","n","k","pe","pb","px","mec","mbc2","alphac")
scenarios=data.frame(scenarios)
set.seed(11131957)
for (i in (1:nrow(scenarios))){
nrep=scenarios[i,1]
nsample=scenarios[i,2]
ksample=scenarios[i,3]
pesample=scenarios[i,4]
pbsample=scenarios[i,5]
pxsample=scenarios[i,6]
mecsample=scenarios[i,7]
mbc2sample=scenarios[i,8]
alphacsample=scenarios[i,9]
MLESMMcTAU=MLESMMcTAU_estimates_MCG(nrep=nrep,n=nsample,k=ksample,
pe=pesample,pb=pbsample,px=pxsample,
mec=mecsample,mbc2=mbc2sample,
alphac=alphacsample)
if (pe>0){
flname=paste0("./Results_Epsilon_contamination/","MLESMMcTAU","_",
"nrep=",nrep,"_",
"n=",nsample,"_",
"k=",ksample,"_",
"pe=",pesample,"_",
"pb=",pbsample,"_",
"px=",pxsample,"_",
"mec=",mecsample,"_",
"mbc2=",mbc2sample,"_",
"alphac=",alphacsample,"_",
".RData")}else{
flname=paste0("./Results_Uncontaminated/","MLESMMcTAU","_",
"nrep=",nrep,"_",
"n=",nsample,"_",
"k=",ksample,"_",
"pe=",pesample,"_",
"pb=",pbsample,"_",
"px=",pxsample,"_",
"mec=",mecsample,"_",
"mbc2=",mbc2sample,"_",
"alphac=",alphacsample,"_",
".RData")}
if (pb>0){
flname=paste0("./Results_Random_Effect_contamination/","MLESMMcTAU","_",
"nrep=",nrep,"_",
"n=",nsample,"_",
"k=",ksample,"_",
"pe=",pesample,"_",
"pb=",pbsample,"_",
"px=",pxsample,"_",
"mec=",mecsample,"_",
"mbc2=",mbc2sample,"_",
"alphac=",alphacsample,"_",
".RData")}
if (px>0){
flname=paste0("./Results_X_contamination/","MLESMMcTAU","_",
"nrep=",nrep,"_",
"n=",nsample,"_",
"k=",ksample,"_",
"pe=",pesample,"_",
"pb=",pbsample,"_",
"px=",pxsample,"_",
"mec=",mecsample,"_",
"mbc2=",mbc2sample,"_",
"alphac=",alphacsample,"_",
".RData")}
save(MLESMMcTAU,file=flname)
}
paste0("./Results_Random_Effect_contamination/","MLESMMcTAU","_",
"nrep=",nrep,"_",
"n=",nsample,"_",
"k=",ksample,"_",
"pe=",pesample,"_",
"pb=",pbsample,"_",
"px=",pxsample,"_",
"mec=",mecsample,"_",
"mbc2=",mbc2sample,"_",
"alphac=",alphacsample,"_",
".RData")
paste0("./Results_Epsilon_contamination/","MLESMMcTAU","_",
"nrep=",nrep,"_",
"n=",nsample,"_",
"k=",ksample,"_",
"pe=",pesample,"_",
"pb=",pbsample,"_",
"px=",pxsample,"_",
"mec=",mecsample,"_",
"mbc2=",mbc2sample,"_",
"alphac=",alphacsample,"_",
".RData")
scenarios
10000/60
# This script prepares the setting for the simulation for
# the MLE, S, MM, and cTAU estimators
# It sources the required R-scripts.
#
# The user first specifies the contamination scenarios.
# The script runs the simulation for these scenarios using
# the function MLESMMcTAU_estimates_MCG and data_gen_MCR
#
# After the simulation for a scenario has been completed
# this script saves the results in .RData files
# containing a list MLESMMcTAU
# The .Rdata files are stored in designated subfolders
# BEFORE running this script, first create subfolders
# - Results_Uncontaminated
# - Results_Epsilon_contamination
# - Results_Random_Effect_contamination
# - Results_X_contamination
source("biweight_functions.R")
source("asympt_norm_constants.R")
source("function_data_gen_MCG.R")
source("Robust_lme.R")
source("function_MLESMMcTAU_estimates_MCG.R")
library(robustbase)
library(lava)
# Information for ourselves
# beta=c(250,10)
# beta1=gamma0
# beta2=gamma1
# theta=c(790,-8.5,40,400)
# theta1=sigma0^2
# theta2=sigma10
# theta3=sigma1^2
# theta4=sigmaeps^2
pe=0.05
pb=0.05
px=0.05
nrep=1
# creating a dataframe that contains different contamination schemes as rows:
# n number of individuals
# k number of observations per individual
# pe probability of having outlier in component epsilon_ij
# pb probability of having outlier in vector of random effects b
# px probability of having outlier in component x_ij in X
# mec shift in the mean of component epsilon_ij
# mbc2 shift in the mean of random effect b2
# alphac multiplication factor in component x_ij in X
scenarios=NULL
scenarios=rbind(scenarios,c(nrep,200,4,pe,0,0,-80,0,1))
scenarios=rbind(scenarios,c(nrep,200,4,0,pb,0,0,-25,1))
scenarios=rbind(scenarios,c(nrep,200,4,0,0,px,0,0,10))
colnames(scenarios)=c("nrep","n","k","pe","pb","px","mec","mbc2","alphac")
scenarios=data.frame(scenarios)
set.seed(11131957)
for (i in (1:nrow(scenarios))){
nrep=scenarios[i,1]
nsample=scenarios[i,2]
ksample=scenarios[i,3]
pesample=scenarios[i,4]
pbsample=scenarios[i,5]
pxsample=scenarios[i,6]
mecsample=scenarios[i,7]
mbc2sample=scenarios[i,8]
alphacsample=scenarios[i,9]
MLESMMcTAU=MLESMMcTAU_estimates_MCG(nrep=nrep,n=nsample,k=ksample,
pe=pesample,pb=pbsample,px=pxsample,
mec=mecsample,mbc2=mbc2sample,
alphac=alphacsample)
if (pesample>0){
flname=paste0("./Results_Epsilon_contamination/","MLESMMcTAU","_",
"nrep=",nrep,"_",
"n=",nsample,"_",
"k=",ksample,"_",
"pe=",pesample,"_",
"pb=",pbsample,"_",
"px=",pxsample,"_",
"mec=",mecsample,"_",
"mbc2=",mbc2sample,"_",
"alphac=",alphacsample,"_",
".RData")}else{
flname=paste0("./Results_Uncontaminated/","MLESMMcTAU","_",
"nrep=",nrep,"_",
"n=",nsample,"_",
"k=",ksample,"_",
"pe=",pesample,"_",
"pb=",pbsample,"_",
"px=",pxsample,"_",
"mec=",mecsample,"_",
"mbc2=",mbc2sample,"_",
"alphac=",alphacsample,"_",
".RData")}
if (pbsample>0){
flname=paste0("./Results_Random_Effect_contamination/","MLESMMcTAU","_",
"nrep=",nrep,"_",
"n=",nsample,"_",
"k=",ksample,"_",
"pe=",pesample,"_",
"pb=",pbsample,"_",
"px=",pxsample,"_",
"mec=",mecsample,"_",
"mbc2=",mbc2sample,"_",
"alphac=",alphacsample,"_",
".RData")}
if (pxsample>0){
flname=paste0("./Results_X_contamination/","MLESMMcTAU","_",
"nrep=",nrep,"_",
"n=",nsample,"_",
"k=",ksample,"_",
"pe=",pesample,"_",
"pb=",pbsample,"_",
"px=",pxsample,"_",
"mec=",mecsample,"_",
"mbc2=",mbc2sample,"_",
"alphac=",alphacsample,"_",
".RData")}
save(MLESMMcTAU,file=flname)
}
# This script contains the code for the function data_gen_MCG.
# This function generates a single dataset according to the model
# in Mason, Cantoni & Ghisletta (2021) with contamination
# generated according to the ICM (independent contamination model
# or cellwise contamination) in the measurement error and
# according to CCM (central contamination model) in the random effects.
# In addition, the function also generates contamination
# in the design matrix of the fixed effects according to ICM.
library(mvtnorm)    # needed for rmvnorm to generate
# a vector of random effects
data_gen_MCG = function(n=200,k=4,pe=0,pb=0,px=0,mec=0,mbc2=0,alphac=1){
# n number of individuals
# k number of observations per individual
# pe probability of having outlier in component epsilon_ij
# pb probability of having outlier in vector of random effects b
# px probability of having outlier in component x_ij in X
# mec shift in the mean of component epsilon_ij
# mbc2 shift in the mean of random effect b2
# alphac multiplication factor in component x_ij in X
X = list()          # list of design matrices for each individual
x1 = rep(1,k)       # first column of design matrix X
x2 = seq(0,k-1,1)   # second column of design matrix X
Zmat = cbind(x1,x2) # design matrix Z of vector of random effects
Z=list(Zmat)        # Creating list for Roblme
# preparing X-list for Roblme
for (i in (1:n)){
X[[i]] <- cbind(x1,x2)
}
# Setting up linear representation of V
Sigma1=matrix(c(1,0,0,0),ncol=2)  # corresponds to var(b1)
Sigma2=matrix(c(0,1,1,0),ncol=2)  # corresponds to covar(b1,b2)
Sigma3=matrix(c(0,0,0,1),ncol=2)  # corresponds to var(b2)
L1=Zmat%*%Sigma1%*%t(Zmat)          # term in V from var(b1)
L2=Zmat%*%Sigma2%*%t(Zmat)          # term in V from covar(b1,b2)
L3=Zmat%*%Sigma3%*%t(Zmat)          # term in V from var(b21)
L4=diag(1,k)                        # term in V from var(epsilon)
# preparing L-list for Roblme
Llist=list()
Llist[[1]]=L1
Llist[[2]]=L2
Llist[[3]]=L3
Llist[[4]]=L4
Y = list()  # preparing Y-list containing individual observations
sb0 = matrix(c(790,-8.5,-8.5,40),2,2)       # var of random effect b
se0=20                                      # sd of eps_ij
mbc = c(0,mbc2)                             # contamination in mean of b
sbc =  matrix(c(7.9,-0.085,-0.085,0.4),2,2) # contamination in var of b
sec = 0.5                                   # contamination sd of eps_ij
# counters for number of contaminated observations/individuals
nobi=0
noe=0
nox=0
noei=0
noxi=0
for (i in (1:n)){
noeitemp=0
noxitemp=0
# generating a random effect
if (runif(1) <= (1-pb)){b= rmvnorm(1, mean=rep(0,2), sigma=sb0)}
else{b=rmvnorm(1, mean=mbc, sigma=sbc);nobi=nobi+1}
# generating measurement error
eps = numeric(k)
# generating components of measurement error
for (kk in (1:k)){
if (runif(1) <= (1-pe)){eps[kk] = rnorm(1, mean=0, sd=se0)}
else{eps[kk] = rnorm(1, mean=mec, sd=sec);noe=noe+1;noeitemp=1}
}
beta0 = c(250,10)  # fixed effects
# construct Y[[i]] according to MCG-model
Y[[i]] =  X[[i]]%*%beta0 + Z[[1]]%*%as.vector(b) + eps
# constructing components of x2 under contamination
for (r in (1:k)){
if(runif(1) <= (1-px)){ X[[i]][r,2]= X[[i]][r,2]}
else{X[[i]][r,2]= alphac*X[[i]][r,2];nox=nox+1;noxitemp=1}
}
# keeping track of number of outliers
noei = noei + noeitemp
noxi = noxi + noxitemp
}
# Setting up Y-matrix for Roblme
Ymat=matrix(0,n,k)
for (i in (1:n)){Ymat[i,] = Y[[i]]}
return(list(Y=Ymat,X=X,Z=Z,L=Llist,
pe=pe,pb=pb,px=px,
mec=mec,mbc2=mbc2,alphac=alphac,
noei=noei,noe=noe,nobi=nobi,noxi=noxi,nox=nox))
}
source("C:/Users/rlopuhaa/surfdrive/LOPUHAA/Research/Toulouse/Visit 2023 Februari/Rstuff Februari 2023/Simulation MCG/function_data_gen_MCG_contCCM.R", echo=TRUE)
source("C:/Users/rlopuhaa/surfdrive/LOPUHAA/Research/Toulouse/Visit 2023 Februari/Rstuff Februari 2023/Simulation MCG/Robust_lme.R", echo=TRUE)
source("C:/Users/rlopuhaa/surfdrive/LOPUHAA/Research/Toulouse/Visit 2023 Februari/Rstuff Februari 2023/Simulation MCG/function_MLESMM_estimates_MCG.R", echo=TRUE)
source("C:/Users/rlopuhaa/surfdrive/LOPUHAA/Research/Toulouse/Visit 2023 Februari/Rstuff Februari 2023/Simulation MCG/function_MLESMMcTAU_estimates_MCG.R", echo=TRUE)
source("C:/Users/rlopuhaa/surfdrive/LOPUHAA/Research/Toulouse/Visit 2023 Februari/Rstuff Februari 2023/Simulation MCG/function_MLESMMcTAU_estimates_MCG_contCCM.R", echo=TRUE)
source("C:/Users/rlopuhaa/surfdrive/LOPUHAA/Research/Toulouse/Visit 2023 Februari/Rstuff Februari 2023/Simulation MCG/function_MLESMMcTAU_estimates_MCG_contCCM.R", echo=TRUE)
